"0","# implementing k-means algorithm..."
"0","# trainx is the n observations"
"0","# k is the number of clusters"
"0","k_means <- function(trainx, k, distance = ""euclidean"") {"
"0","  # Define the distance function based on the specified distance metric"
"0","  distance_function <- switch(distance,"
"0","                              euclidean = function(a, b) sqrt(sum((a - b)^2)),"
"0","                              manhattan = function(a, b) sum(abs(a - b)),"
"0","                              mahalanobis = function(a, b) "
"0","                                sqrt(as.matrix(a - b) %*% cov_inv %*% as.matrix(t(a - b))),"
"0","                              custom = function(a, b) "
"0","                                sqrt(as.matrix(a - b) %*% Q %*% as.matrix(t(a - b))),"
"0","                              stop(""Unsupported distance metric""))"
"0","  if (distance == ""mahalanobis"") {"
"0","    # Compute the inverse of the covariance matrix"
"0","    cov_mat <- cov(trainx)"
"0","    cov_inv <- solve(cov_mat)  # Inverse of the covariance matrix"
"0","  }"
"0","  if (distance == ""custom"") {"
"0","    Q <- matrix(c(1, -2, -2, 10), nrow = 2, ncol = 2, byrow = TRUE)"
"0","  }"
"0","  "
"0","  # Find the number of observations"
"0","  n <- nrow(trainx)"
"0","  # Randomly assign a number 1 to k for each of the n observations"
"0","  cluster_assignments <- sample(1:k, n, replace = TRUE)"
"0","  keep_going <- TRUE"
"0","  "
"0","  while (keep_going) {"
"0","    keep_going <- FALSE"
"0","    centroids <- matrix(0, nrow = k, ncol = ncol(trainx))"
"0","    "
"0","    # Compute the centroids for each cluster"
"0","    for (i in 1:k) {"
"0","      k_data <- trainx[which(cluster_assignments == i), ]"
"0","      if (nrow(k_data) > 0) {"
"0","        centroids[i, ] <- colMeans(k_data)"
"0","      }"
"0","    }"
"0","    "
"0","    new_assignments <- cluster_assignments"
"0","    "
"0","    # Reassign points to the nearest centroid"
"0","    for (i in 1:n) {"
"0","      distances <- apply(centroids, 1, function(centroid) distance_function(trainx[i, ], centroid))"
"0","      new_assignments[i] <- which.min(distances)"
"0","    }"
"0","    "
"0","    # Check if there are any changes in assignments"
"0","    if (!all(new_assignments == cluster_assignments)) {"
"0","      keep_going <- TRUE"
"0","    }"
"0","    "
"0","    cluster_assignments <- new_assignments"
"0","  }"
"0","  "
"0","  list(assignments = cluster_assignments, centroids = centroids)"
"0","}"
"0",""
"0",""
"0","# run the k-means algorithm with euclidean distance..."
"0","trainx <- pokemon_data[, c(""speed"", ""base_experience"")]"
"0","k_means_result <- k_means(trainx, 3, ""euclidean"")"
"0","trainx$cluster <- as.factor(k_means_result$assignments)"
"0",""
"0","# Convert centroids to a data frame with appropriate column names"
"0","centroids_df <- data.frame(k_means_result$centroids)"
"0","colnames(centroids_df) <- colnames(trainx)[1:2]"
"0","centroids_df$cluster <- as.factor(1:nrow(centroids_df))"
"0",""
"0","# Plotting"
"0","ggplot(trainx, aes(x = speed, y = base_experience, color = cluster)) +"
"0","  geom_point() +"
"0","  geom_point(data = centroids_df, aes(x = speed, y = base_experience, color = cluster), "
"0","             shape = 17, size = 8) +"
"0","  labs(color = ""Cluster"") +"
"0","  theme_minimal() +"
"0","  ggtitle(""K-Means Clustering of PokÃ©mon Data (Euclidian Distance)"") +"
"0","  xlab(""Speed"") +"
"0","  ylab(""Base Experience"")"
