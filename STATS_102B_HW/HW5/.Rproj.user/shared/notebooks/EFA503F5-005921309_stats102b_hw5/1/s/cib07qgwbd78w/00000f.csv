"0","# trainx: a data frame of the training observations"
"0","# trainy: a vector of the training labels"
"0","# testx: a data frame of the testing (new) observations"
"0","# k: the number of neighbors"
"0","# output: a vector of the predicted labels corresponding to the new observations"
"0",""
"0","# first write helper function to get Euclidean Distance given a vector x and y of equal length:"
"0","GetEuclidianDistance <- function(x, y) {"
"0","  result <- sqrt(sum((x - y)^2))"
"0","  # return the result"
"0","  result"
"0","}"
"0",""
"0","# knn function implementation:"
"0","knn <- function(trainx, trainy, testx, k) {"
"0","  # set result to be empty vector:"
"0","  result <- c()"
"0","  "
"0","  # for each new testx case:"
"0","  for (i in 1:nrow(testx)) {"
"0","    # create empty distances vector"
"0","    distances <- c()"
"0","    # compute the distance between the test case and each training observation:"
"0","    for (j in 1:nrow(trainx)) {"
"0","      distance <- GetEuclidianDistance(testx[i, ], trainx[j, ])"
"0","      # append distance to distance vector"
"0","      distances <- append(distances, distance)"
"0","    }"
"0","    # create a data frame of distances and indexes, then arrange by increasing distance"
"0","    indexes <- c(1:length(trainy))"
"0","    point_data_frame <- data.frame(distances = distances, indexes = indexes) %>% arrange(distances)"
"0","    # choose the k nearest neighbors:"
"0","    interested_indexes <- point_data_frame$indexes[1:k]"
"0","    # get the extracted y labels:"
"0","    nearest_labels <- trainy[interested_indexes]"
"0","    freq_table <- table(nearest_labels)"
"0","    label <- names(freq_table[which.max(freq_table)])"
"0","    # append label to the result"
"0","    result <- append(result, label)"
"0","  }"
"0","  # convert result to logical"
"0","  result <- as.logical(result)"
"0","  # return the result"
"0","  result"
"0","}"
