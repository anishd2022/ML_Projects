"0","# g: function from R -> R"
"0","# grad_g: gradient of g, a function \del g: R -> R"
"0","# alpha: step size"
"0","# w0: initial point"
"0","# K: number of iterations"
"0","grad_desc <- function(g, grad_g, alpha, w0, K) {"
"0","  # create initial list object"
"0","  result <- list(index = c(), val = c(), coord_matrix = c())"
"0","  # establish current point"
"0","  curr_point <- w0"
"0","  indexes <- c()"
"0","  # create initial matrix (ncol = 2, since only one dimension)"
"0","  mat <- matrix(nrow = K, ncol = 2)"
"0","  "
"0","  # iterate for K iterations..."
"0","  for (i in 1:K) {"
"0","    # calculate gradient at current step"
"0","    grad_curr <- grad_g(curr_point)"
"0","    # update... "
"0","    mat[i, 1] <- curr_point - alpha * grad_curr"
"0","    curr_point <- mat[i, 1]"
"0","    # add current point to index"
"0","    indexes <- append(indexes, curr_point)"
"0","  }"
"0","  "
"0","  eval_points <- g(indexes)"
"0","  mat[ , 2] <- eval_points"
"0","  min_val <- min(eval_points)"
"0","  min_index <- indexes[which(eval_points == min_val)]"
"0","  "
"0","  result$index <- min_index"
"0","  result$val <- min_val"
"0","  result$coord_matrix <- mat"
"0","  "
"0","  # return the result object:"
"0","  result"
"0","}"
