"0","# g: a function R^n -> R"
"0","# h: a small step size in the x direction"
"0","# k: a small step size in the y direction"
"0","# w0: initial point"
"0","# K: number of iterations"
"0","newts_method_num <- function(g, h, k, w0, K) {"
"0","  # create initial list object:"
"0","  result <- list(index = c(), val = c())"
"0","  "
"0","  # set initial point:"
"0","  curr_point <- w0"
"0","  # create initial empty coordinate matrix: (ncol = n+1)"
"0","  mat <- matrix(nrow = K, ncol = length(w0) + 1)"
"0","  "
"0","  # creating a gradient function:"
"0","  grad_g <- function(x) {"
"0","    result_vec <- c()"
"0","    for (i in 1:length(x)) {"
"0","      # create standard basis vector"
"0","      sbv <- rep(0, length(w0))"
"0","      sbv[i] <- 1"
"0","      current_result <- (g(x + h*sbv) - g(x - h*sbv)) / (2*h)"
"0","      result_vec <- append(result_vec, current_result)"
"0","    }"
"0","    result_vec"
"0","  }"
"0","  "
"0","  # creating a hessian function:"
"0","  hess_g <- function(x) {"
"0","    h_vec <- c(1, 0)"
"0","    k_vec <- c(0, 1)"
"0","    hk_vec <- c(h, k)"
"0","    fxx <- (g(x + h*h_vec) - 2*g(x) + g(x - h*h_vec)) / h^2"
"0","    fyy <- (g(x + k*k_vec) - 2*g(x) + g(x - k*k_vec)) / k^2"
"0","    fxy <- (g(x + hk_vec*c(1, 1)) - g(x + hk_vec*c(1, -1)) - "
"0","              g(x + hk_vec*c(-1, 1)) + g(x + hk_vec*c(-1, -1))) / 4*h*k"
"0","    result <- matrix(c(fxx, fxy, fxy, fyy), nrow = 2, byrow = TRUE)"
"0","    result"
"0","  }"
"0","  "
"0","  # iterate for K iterations:"
"0","  for (i in 1:K) {"
"0","    # calculate gradient at current step:"
"0","    grad_curr <- grad_g(curr_point)"
"0","    # calculate hessian at current step:"
"0","    hess_curr <- hess_g(curr_point)"
"0","    # calculate inverse of the hessian:"
"0","    inv_hess <- solve(hess_curr)"
"0","    # update step..."
"0","    mat[i, 1:length(w0)] <- curr_point - inv_hess %*% grad_curr"
"0","    curr_point <- mat[i, 1:length(w0)]"
"0","    # fill out function output given current point"
"0","    mat[i, length(w0) + 1] <- g(curr_point)"
"0","  }"
"0",""
"0","  inputs <- mat[ , 1:length(w0)]"
"0","  outputs <- mat[ , length(w0) + 1]"
"0","  min_val <- min(outputs)"
"0","  # check if there are duplicate minimum values"
"0","  min_indices <- which(outputs == min_val)"
"0","  num_min_indices <- length(min_indices)"
"0","  if (num_min_indices > 1) {"
"0","    # if there are multiple min values, choose the first one"
"0","    min_index <- inputs[min_indices[1], ]"
"0","  } else {"
"0","    # If there is only one unique minimum value, directly extract its index "
"0","    min_index <- inputs[min_indices, ]"
"0","  }"
"0","  "
"0","  result$index <- min_index"
"0","  result$val <- min_val"
"0","  "
"0","  # return result"
"0","  result"
"0","}"
