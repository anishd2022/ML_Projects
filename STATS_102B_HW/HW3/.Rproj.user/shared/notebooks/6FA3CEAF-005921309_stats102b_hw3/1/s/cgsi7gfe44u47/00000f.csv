"0","# g: function R^n -> R"
"0","# grad_g: gradient of g, a function \del g: R^n -> R^b"
"0","# w0: initial point"
"0","# K: number of iterations"
"0","bfgs <- function(g, grad_g, w0, K) {"
"0","  # create initial list object:"
"0","  result <- list(index = c(), val = c())"
"0","  # set initial point:"
"0","  curr_point <- w0"
"0","  # create initial empty coordinate matrix: (ncol = n+1)"
"0","  mat <- matrix(0, nrow = K, ncol = length(w0) + 1)"
"0","  # set initial hessian approximation to be the identity matrix"
"0","  curr_hess <- diag(length(w0))"
"0","  # set initial gradient to be the gradient at the current point"
"0","  curr_grad <- grad_g(curr_point)"
"0","  "
"0","  # iterate for K iterations or until convergence:"
"0","  for (i in 1:K) {"
"0","    prev_point <- curr_point"
"0","    prev_hess <- curr_hess"
"0","    prev_grad <- curr_grad"
"0","    "
"0","    # update the current values..."
"0","    curr_point <- prev_point - solve(prev_hess, prev_grad)"
"0","    curr_grad <- grad_g(curr_point)"
"0","    # introduce x_k and y_k"
"0","    x_k <- curr_point - prev_point"
"0","    y_k <- curr_grad - prev_grad"
"0","    "
"0","    # update the current hessian approximation"
"0","    skTyk <- as.numeric(t(x_k) %*% y_k)"
"0","    if (skTyk == 0) {"
"0","      curr_hess <- prev_hess"
"0","    } else {"
"0","      curr_hess <- prev_hess + (y_k %*% t(y_k)) / skTyk -"
"0","        (prev_hess %*% x_k) %*% t(prev_hess %*% x_k) / (as.numeric(t(x_k) %*% prev_hess %*% x_k))"
"0","    }"
"0","    "
"0","    # add info to output matrix"
"0","    mat[i, 1:length(w0)] <- curr_point"
"0","    # fill out function output given current point"
"0","    mat[i, length(w0) + 1] <- g(curr_point)"
"0","    "
"0","    # check for convergence"
"0","    if (norm(as.matrix(curr_grad)) < 1e-6 || norm(as.matrix(curr_point) - as.matrix(prev_point)) < 1e-6) {"
"0","      if (i > 2) {"
"0","        break"
"0","      }"
"0","    }"
"0","  }"
"0","  "
"0","  # Remove extra rows from mat (if convergence happened before K iterations)"
"0","  mat <- mat[1:i, ]"
"0","  "
"0","  inputs <- mat[ , 1:length(w0)]"
"0","  outputs <- mat[ , length(w0) + 1]"
"0","  min_val <- min(outputs)"
"0","  # check if there are duplicate minimum values"
"0","  min_indices <- which(outputs == min_val)"
"0","  num_min_indices <- length(min_indices)"
"0","  if (num_min_indices > 1) {"
"0","    # if there are multiple min values, choose the first one"
"0","    min_index <- inputs[min_indices[1], ]"
"0","  } else {"
"0","    # If there is only one unique minimum value, directly extract its index "
"0","    min_index <- inputs[min_indices, ]"
"0","  }"
"0","  "
"0","  result$index <- min_index"
"0","  result$val <- min_val"
"0","  # return result"
"0","  result"
"0","}"
